/*

 J2ds - 2D движок для взаимодействия с API HTML5
 Автор / Разработчик: Нагель Петр (Skaner)
 Сайт движка: https://sites.google.com/site/j2dsdemgam/
 Дата начала разработки: 25 августа 2015
 
*/


API движка:

API системы распределено по отдельным файлам, каждый из
которых взаимодействует со своей функциональной частью
но все файлы зависят друг от друга.


/*-------- Работа с объектами и сценой ---------*/
Основной файл для подключение графического движка
<script type="text/javascript" src="j2ds.js"></script>


// Cтарт игры
scene.start(GameState, fps);

запускает игровой движок с указанным FPS
GameEngine - игровое состояние. В любой момент времени
игра может находиться только в одном игровом состоянии.

// Сменяет игровое состояние на то, что указано движку
scene.setEngine(newGameState);

// Например, можно определить функцию GameOver
// и Использовать setActivEngine(GameOver);


// Создание сцены на основе сanvas
scene.init('idCanvas', // Первый агрумент - id объекта Сanvas
           '#dddddd'); // Второй агрумент - цвет фона

//Развернуть игру на весь экран
scene.fullScreen(true);

//Не растягивать на весь экран
scene.fullScreen(false);




Любые операции над координатами в 2D пространстве выполняются при помощи vec2df(x , y)


// Функция вывода текста без GUI
scene.drawTextOpt( 
                   vec2df(2, 20), // Позиция
                  'Привет, Мир!', // Текст
                  '20px sans-serif', // Шрифт (аналогично CSS)
                  '#000', // Цвет текста
                  '#fff', // Цвед обводки
                  2 // Толщина обводки
                  ); 


// Рисует текст шрифтом по умолчанию
scene.DrawText(vec2df(2, 2),  // Позиция
               'Tutorial #1'); // Текст

// Установить камеру в позицию
scene.setViewPosition(vec2df(x, y));

// "Следить" за объектом
scene.setViewFocus(a); // a - базовый объект или его потомок

scene.setViewFocus(a, vec2df(100, 0));  // Сместит взгляд по оси X (опционально)

// Двигать камеру по осям
scene.viewMove(vec3df(x, y));

// Очистка игрового окна
scene.clearDraw(); // В качестве параметра можно
// передать альтернативный цвет scene.clearDraw('red');




Объекты


// Создание "базового объекта", не имеет функций отрисовки,
// но имеет все описанные ниже функции
a= addBaseNode(vec2df(x, y), vec2df(Width, Height));


// Вращение объекта
a.turn(angle);  // angle , 0 - 360

// Задать угол вращения
a.setRotation(angle); // angle , 0 - 360 

// Управление объектом с клавиатуры
a.keyControl(speed); // Скорость движения

// Установить видимость объекта
a.setVisible(true); // false - невидимый объект

// Движение объекта
a.move(vec2df(x, y)); // Скорость по осям

// Движение на объект
a.moveTo(b); // b - базовый объект или его потомок

// Движение объекта в своем направлении
a.moveDir(speed); // 

// Установить объект в позицию
a.setPosition(vec2df(x, y));
 
// Получить позицию центра объекта
a.getPosition();
// Возвращает vec2df с двумя координатами x и y

// Установить новые размеры изображения
a.setScale(vec2df(x, y));

// Привязать объект "a" к объекту "b"
a.setParent(b);

// Получить расстояние между "a" и "b"
a.getDistance(b);

// Получение расстояния до объекта по осям
// Вернет объект с двумя переменными x, y
a.getDistanceXY(b).x // Расстояние по оси X
a.getDistanceXY(b).y // Y


// Вернет true, если "a" и "b" стулкнутся
a.isCollision(b);



// Вернет true, если "a" и "b" стулкнутся
// Проверка идет по эллипсоиду, описывающую 
// контур объекта
a.collisionRadius(b);



// Вернет true, если объект в пределах видимости камерой
a.isLookScene();

// Проверить столкновение с границами видимости сцены
a.isCollisionScene() // вернет объект с тремя переменными:
x == 1 - правай сторона, x == -1 - левая сторона
y == 1 - низ, x == -1 - верх
all = true - лбой вариант столкнокения






// Потомок базового объекта
// Создает прямоугольник
a= addRectNode( 
               vec2df(x, y), // Положение
               vec2df(x, y), // Размеры
               'rgb(150,100,100)' // Цвет
              );


a= addCircleNode(
                 vec2df(x, y), // Позиция
                 radius,
                 color
);
              
              
              
// Рисование
a.draw(); // scene - объект сцены






Изображения и спрайты
<img id="imageMap" src="image.jpg" alt="">

// Создание карты изображения
imageMap= createImageMap('imageMap'); // id объекта HTML

// Создание анимации из имеющейся карты
anim= imageMap.createAnimation(
                 0, 0,   // Начальная позция первого кадра
                 96, 87, // Размер кадра
                 2       // Количество кадров (по горизонтали)
                 );
               
// Потомок базового объекта
// Создание спрайта
a= addSpriteNode(
    vec2df(x, y), // Позиция в игре
    vec2df(x, y), // Размеры в игре
    anim    // Анимация
   );

// Рисование одного кадра спрайта             
a.drawFrame(frame); // сцена, номер кадра (1 - первый)

// Проигрывать всю анимацию
a.drawAnimate(speed); // сцена, скорость (чем больше, тем медленнее)

// Установить анимацию спрайту
a.setAnimation(anim); // объект анимации







/*-------- enginePostEffects ---------*/
Основной файл для подключения движка пост обработки
<script type="text/javascript" src="post.js"></script> 
 
post= createPost(); // создает обработчик и привязывает его ко сцене

// Эффект сепии
post.sepia(vol); // vol - осветление или затемнение (- 0 +)

// Инвертировать цвета
post.invert(); 

// Наклнить сцену
post.setRotation(angle); // angle , 0 - 360

// осветлить изи затенить сцену
post.lightness(vol); 


// moution Blur / Размытие при движении
post.motionBlur(vol);

// Размытие Гаусса
post.blurBETA(vol);

// Размытие при движении 2
post.alphaBlur(vol);

// функция преобразования Mirror
post.mirror(x_true, y_true);








/*-------- engineNet ---------*/
Основной файл для подключения сетевого движка (Не доделан)
<script type="text/javascript" src="net.js"></script>

// Jткрытие потока для работы с АJAX
var myAjax= startajax(); 

// Отправить запрос на сервер и обработать
// результат функцией 
getAjax(myAjax, // объект АJAX потока
        script, // адрес скрипта на сервере (напр. 'server.php')
        func); // Функция, обрабатывающая результат

// Описание функции обработчика
function func(result){
 alert('Сервер вернул ответ: '+result);
}



// Локальное хранилище
myLocal= createLocal(id); // id - любое уникальное значение (строковое)

// Сохранение данных
myLocal.save(id, value); // data.save('name', 'Василий');

// Загрузка данных
myLocal.load(id); // data.load('name').val; // Вернет "Василий"
// Вернет объект:
  val - текстовое значение
  int - целочисленное
  dbl - вещественное

// Сохранение данных
myLocal.saveObject(id, value); // data.save('name', me); // Сохранит все свойства объекта

// Загрузка данных
myLocal.loadObject(id); // Вернет объект


// Проверка существования локальной переменной
myLocal.is(id);
if (myLocal.is(id)) alert('Есть такая переменная');




/*-------- engineMath ---------*/
Основной файл для подключения движка 
Дополнительных математических функций
<script type="text/javascript" src="math.js"></script> 
 
// Вернет рандомное число между min и max
var rnd= Random(min, max);

var rad= Rad(50); // переводит в радианы







/*-------- engineDOM ---------*/
Основной файл для подключение функций работы с DOM
Деревом документа
<script type="text/javascript" src="dom.js"></script>

// Функция обращения к объекту по ID
obj(id); 

// Функция возвращает размер экрана, доступный для показа
device().width // Ширина
device().height // Высота







/*-------- engineInput ---------*/
Основной файл для подключение функций работы с клавиатурой
<script type="text/javascript" src="input.js"></script>

Для работы с мышью есть следующие функции 
// Координаты в игровом мире
input.pos - vec2df объект с координатами x и y
input.abs - vec2di объект с координатами относительно страницы


// Координаты, проецирующиеся на СANVAS 
input.x
input.y


// Можно так же проверить нажатие клавиши мыши
// или Нажатие тачскрина (сенсорного экрана)
// true / false Нажатия ЛКМ
// true, пока не будет отпущена
input.lClick

// И аналогично для ПКМ
input.rClick

// И для Средней кнопки
input.mClick




input - Основной объект ввода

// Чтобы указанные выше координаты обрабатывались корректно
// Нужно функцию поместить в начало игрового цикла
// Обновление координат мыши
input.upd(); // Сцена

// Вернет true, если курсор над объектом
input.onNode(a); // Объекь

// Инициализируем клавиатуру для
// объекта <body> с id="gameBody"
// Эту функцию нужно поместить сразу после открытия <body>
// Нужна, только если вы хотите пользоваться клавиатурой
initInput(scene);

Для проверки нажатий клавишь достаточно использовать
следующую конструкцию: input.keyDown[Key.LEFT], где Key - объект клавиши и возвращает сканкод
if (input.keyDown[Key.LEFT]) dbg('Нажата клавиша ЛЕВО');













